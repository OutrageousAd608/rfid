/**
  ******************************************************************************
  * @file    rf_driver.c
  * @brief   Implementation of RF Capture & Replay using TIM2.
  * Handles ISR logic and precise timing generation.
  ******************************************************************************
  */

#include "rf_driver.h"
#include "tim.h" // Generated by STM32CubeMX

// Global Instance
volatile RF_Capture_State rf_rx;

// Internal tracking variable for the last edge timestamp
static uint32_t last_timestamp = 0;

// --- PRIVATE HELPERS ---

/**
 * @brief  Microsecond blocking delay using TIM2.
 * @param  us: Microseconds to wait.
 */
static void delay_us(uint32_t us) {
    uint32_t start = __HAL_TIM_GET_COUNTER(&htim2);
    
    // Wait until the difference matches 'us'.
    // Automatically handles 32-bit counter wrap-around.
    while ((__HAL_TIM_GET_COUNTER(&htim2) - start) < us) {
        __NOP(); // Burn CPU cycles while waiting
    }
}

// --- PUBLIC FUNCTIONS ---

void RF_Init(void) {
    rf_rx.count = 0;
    rf_rx.is_capturing = 0;
    rf_rx.capture_complete = 0;
}

void RF_Start_Capture(void) {
    if (rf_rx.is_capturing) return;

    // Reset State
    rf_rx.count = 0;
    rf_rx.capture_complete = 0;
    rf_rx.is_capturing = 1;
    last_timestamp = 0;

    // Reset Hardware Timer to 0 to prevent immediate overflow confusion
    __HAL_TIM_SET_COUNTER(&htim2, 0);

    // Enable Input Capture Interrupts (Channel 1, Both Edges)
    HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);
}

void RF_Stop_Capture(void) {
    HAL_TIM_IC_Stop_IT(&htim2, TIM_CHANNEL_1);
    rf_rx.is_capturing = 0;
}

void RF_Transmit(volatile uint32_t *timings, uint16_t length) {
    // 1. Ensure capture is stopped to prevent interrupt interference
    RF_Stop_Capture();

    // 2. Ensure Timer is running (needed for delay_us)
    HAL_TIM_Base_Start(&htim2);

    // 3. Replay Loop
    // ASK/OOK Signals typically start with a HIGH pulse
    for (uint16_t i = 0; i < length; i++) {
        
        if (i % 2 == 0) {
            // Even index (0, 2, 4...) -> HIGH
            HAL_GPIO_WritePin(RF_TX_GPIO_PORT, RF_TX_PIN, GPIO_PIN_SET);
        } else {
            // Odd index (1, 3, 5...) -> LOW
            HAL_GPIO_WritePin(RF_TX_GPIO_PORT, RF_TX_PIN, GPIO_PIN_RESET);
        }

        // Hold the state for the recorded duration
        delay_us(timings[i]);
    }

    // 4. Cleanup: Ensure pin is LOW when finished
    HAL_GPIO_WritePin(RF_TX_GPIO_PORT, RF_TX_PIN, GPIO_PIN_RESET);
}

void RF_Handle_IRQ(TIM_HandleTypeDef *htim) {
    // Safety Checks
    if (htim->Instance != TIM2) return;
    if (!rf_rx.is_capturing) return;
    
    // Stop if buffer is full to prevent memory overflow
    if (rf_rx.count >= RF_BUFFER_SIZE) {
        RF_Stop_Capture();
        rf_rx.capture_complete = 1;
        return;
    }

    // 1. Read Current Timestamp (in Microseconds)
    uint32_t current_time = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
    
    // 2. Calculate Pulse Duration
    uint32_t duration;
    if (current_time >= last_timestamp) {
        duration = current_time - last_timestamp;
    } else {
        // Handle Timer Overflow (wrap-around)
        duration = (0xFFFFFFFF - last_timestamp) + current_time;
    }

    // 3. Store Valid Pulses
    // Filter out extremely short noise defined in MIN_PULSE_LEN
    if (duration > MIN_PULSE_LEN) {
        rf_rx.timings[rf_rx.count] = duration;
        rf_rx.count++;
    }

    // 4. Update timestamp for the next edge
    last_timestamp = current_time;
}

uint8_t RF_Process(void) {
    // 1. Check if buffer filled up naturally
    if (rf_rx.capture_complete) return 1;

    // 2. Smart Timeout Logic
    // Only check for timeout if we have actually started receiving data.
    // This allows waiting indefinitely for the first pulse.
    if (rf_rx.is_capturing && rf_rx.count > 0) {
        
        uint32_t now = __HAL_TIM_GET_COUNTER(&htim2);
        uint32_t gap;
        
        if (now >= last_timestamp) {
            gap = now - last_timestamp;
        } else {
            gap = (0xFFFFFFFF - last_timestamp) + now;
        }
        
        // Timeout Logic:
        // If silence lasts > RF_SILENCE_TIMEOUT, assume packet is finished.
        if (gap > RF_SILENCE_TIMEOUT) {
            RF_Stop_Capture();
            rf_rx.capture_complete = 1;
            return 1; // Signal Capture Complete
        }
    }
    
    return 0; // Still capturing or waiting
}

// --- HAL HOOK ---
// Redirects the STM32 driver callback to our custom logic
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim) {
    RF_Handle_IRQ(htim);
}