#include "touch.h"
#include "spi.h"
#include "ili9341.h"
#include "fonts.h"
#include <string.h> // Needed for strlen

// XPT2046 Commands
#define CMD_X_READ  0x90
#define CMD_Y_READ  0xD0

// --- PRIVATE HELPERS ---

// 1. Sorts an array (Low -> High) using Insertion Sort
static void Sort_Array(uint16_t *arr, uint8_t n) {
    for (uint8_t i = 1; i < n; i++) {
        uint16_t key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

// 2. Single Low-Level SPI Read
static uint16_t TP_ReadAxis_Raw(uint8_t cmd) {
    uint8_t data_tx[3] = {cmd, 0x00, 0x00};
    uint8_t data_rx[3];

    HAL_GPIO_WritePin(TOUCH_CS_GPIO_Port, TOUCH_CS_Pin, GPIO_PIN_RESET);
    HAL_SPI_TransmitReceive(&hspi2, data_tx, data_rx, 3, 10);
    HAL_GPIO_WritePin(TOUCH_CS_GPIO_Port, TOUCH_CS_Pin, GPIO_PIN_SET);

    return ((data_rx[1] << 8) | data_rx[2]) >> 3;
}

// 3. OLYMPIC FILTER: The "Nuclear Option" for stability
// Reads 16 samples, discards 4 highest and 4 lowest, averages the middle 8.
static uint16_t TP_ReadAxis(uint8_t cmd) {
    uint16_t samples[16];
    uint32_t total = 0;

    // A. Capture 16 samples
    for (int i = 0; i < 16; i++) {
        samples[i] = TP_ReadAxis_Raw(cmd);
    }

    // B. Sort them
    Sort_Array(samples, 16);

    // C. Average the middle 8 (Index 4 to 11)
    // This removes the spikes at the top and bottom arrays
    for (int i = 4; i < 12; i++) {
        total += samples[i];
    }

    return total / 8;
}

// --- PUBLIC FUNCTIONS ---

uint8_t Touch_IsPressed(void) {
    return (HAL_GPIO_ReadPin(TOUCH_IRQ_GPIO_Port, TOUCH_IRQ_Pin) == GPIO_PIN_RESET);
}

uint8_t Touch_GetPixels(uint16_t *x, uint16_t *y) {
    if (!Touch_IsPressed()) return 0;

    // 1. Read Filtered Data
    uint16_t raw_x = TP_ReadAxis(CMD_X_READ);
    uint16_t raw_y = TP_ReadAxis(CMD_Y_READ);

    // 2. Noise Gate
    // If the data is near 0 or 4095, it's a "floating wire" or open circuit glitch.
    if (raw_x < 100 || raw_x > 4000) return 0;
    if (raw_y < 100 || raw_y > 4000) return 0;

    // 3. GEOMETRY MATH
    // NOTE: Based on calibration, Raw X controls Screen Y, and Raw Y controls Screen X.

    // -- CALCULATE SCREEN Y (Vertical) --
    // Constrain to Calibration Limits
    if (raw_x < RAW_X_MIN) raw_x = RAW_X_MIN;
    if (raw_x > RAW_X_MAX) raw_x = RAW_X_MAX;

    // Map Raw X range to Screen Height
    *y = (uint32_t)(raw_x - RAW_X_MIN) * ILI9341_HEIGHT / (RAW_X_MAX - RAW_X_MIN);

    // -- CALCULATE SCREEN X (Horizontal) --
    // Constrain to Calibration Limits
    if (raw_y < RAW_Y_MIN) raw_y = RAW_Y_MIN;
    if (raw_y > RAW_Y_MAX) raw_y = RAW_Y_MAX;

    // Map Raw Y range to Screen Width (INVERTED logic)
    // High Raw Value (e.g. 3500) = Left Edge (0)
    // Low Raw Value (e.g. 300) = Right Edge (320)
    *x = ILI9341_WIDTH - ((uint32_t)(raw_y - RAW_Y_MIN) * ILI9341_WIDTH / (RAW_Y_MAX - RAW_Y_MIN));

    return 1;
}

uint8_t Button_IsPressed(ButtonDef button, uint16_t touch_x, uint16_t touch_y) {
    // Check if the touch coordinate is inside the button box
    if (touch_x >= button.x && touch_x <= (button.x + button.width) &&
        touch_y >= button.y && touch_y <= (button.y + button.height)) {
        return 1;
    }
    return 0;
}

void Button_Draw(ButtonDef *btn, const char* label, uint16_t color, uint16_t text_color) {
    LCD_FillRect(btn->x, btn->y, btn->width, btn->height, color);

    // Auto-Center Text Calculation
    // Font_7x10: Width = 7px, Height = 10px
    uint16_t text_len = strlen(label) * 7;

    // Prevent crash if text is wider than button
    uint16_t x_center;
    if (text_len < btn->width) {
        x_center = btn->x + (btn->width - text_len) / 2;
    } else {
        x_center = btn->x + 2; // Left align with padding if too big
    }

    uint16_t y_center = btn->y + (btn->height - 10) / 2;

    LCD_WriteString(label, x_center, y_center, Font_7x10, text_color, color);
}
